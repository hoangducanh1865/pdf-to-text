A de Bruijn sequence, or a positioning sequence, (of order k) is a binary se quence in which every possible length- kstring appears exactly once as a substring.
The uses of de Bruijn sequences have been found in various fields. Recently, anovel application of positioning sequences has been found in quantum communication by Zhang, Oi, Lowndes, et al. They adopt such sequences into HdB sequences to develop a system for synchronizing in quantum channels. Though hav ing shown advantages against other methods , such implementation still hasdrawbacks and there is room for improvements. This thesis focuses on design ing a new constrained de Bruijn sequence and proving its efficiency against HdB sequence.
Chapter 1 first briefly introduces the QKD protocol, along with the reasonablemotivation to study the synchronization mechanisms in satellite quantum chan nels. Among such mechanisms, the timing and synchronization system proposed by Zhang, Oi, Lowndes, et al. in  is analyzed to recognize its disadvantages.
The main results of this thesis, which aim to improve those weaknesses, are sum marized. The organization of the whole thesis is given at the end of this chapter.
1.1 Timing and synchronization system in quantum channels
Symmetric, public-key (asymmetric), and hash-based cryptography are fundamental pillars of modern cryptography. While symmetric schemes and hash func tions are less vulnerable to quantum attacks, the asymmetric schemes based onfactoring or solving the discrete logarithm problem, for example, Rivest-ShamirAdelman (RSA), Elliptic Curve Cryptography, are completely broken by a quantum adversary via Shor’s algorithm . Currently deployed public key cryptosys tems are used to establish a common secret key between two parties. Doing the same jobs, QKD enables two parties to produce a shared random secret key known only to them. Moreover, QKD can guarantee the security of communication links making them immune to quantum computer-based attacks .
The first invented QKD protocols are BB84 , and E91 . Since 2005, QKDhas been initially implemented in real life. For example, in 2005, the Univer sity of Geneva and Corning Inc used a fiber optic wire of 307km. In 2007, LosAlamos National Laboratory and the National Institute of Standards and Tech nology (NIST) used the BB84 protocol over a 148.7 km optical fiber. In 2018, Quantum Xchange launched the first quantum network in the U.S., offering 1,000 km of fiber optic cable and 19 colocation centers along the Boston-to-Washington,D.C., corridor and metro hubs. However, due to the intrinsic exponential losses over optical fiber, the deployed QKD systems’ range is restricted to under 1000 km. So as to establish intercontinental secure communication links, which usually require a range over 1000 km, satellite QKD has been proposed as an alternative, with the pioneering Micius satellite. In these systems, the transmitter (satellite) andthe receiver (optical ground station) relentlessly exchange information after mea suring the quantum states. But transmitting faint quantum optical pulses between a satellite and the Earth is challenging due to high channel losses cause by volatility environments and rapid relative motion between two parties.
To deal with this problem, reliable and efficient timing and synchronization systems have been proposed in , . In this system, a classical channel is used along with the quantum channel, because of its advantage in synchronization.
Based on that concept, in , a de Bruijn based timing and synchronization system is introduced using a beacon with an on-off model. In this model, a de Bruijn sequence is transmitted from the satellite to the ground for synchronization.
The superiority of this system relies on the intrinsic property of the positioning sequence, which is self-located. However, in dBTS, the method  use requires 2pulse slots to modulate 1bit to balance encoding sequence with timing jitter performance. Consequently, the (information) rate of the transmitted sequence, called HdB sequence is 0.5. The formal definition of information rate is given section 2.1.2. This quantity is usually expected to be as high as possible.
Moreover, to generate positioning sequences, dBTS applies Linear feedback shift register algorithm, which is fast, but depends on finding a suitable primitivepolynomial first. To determine the location of a subsequence in the whole position ing sequence, the system uses a look up table, which is a costly approach. More details about the generate algorithm, look-up table, and the analysis of this system are presented in the next chapter.
1.2 The contributions and organization of this thesis
Such flaws of Zhang, Oi, Lowndes, et al. ’s system, fortunately, can still be improved. That is the goal this thesis aims to. The main task here is to design a code satisfying the constraints of dBTS system.
Problem Statement : Designing a high rate sequence that is capable of posi tioning and avoids long periods with no pulse This problem is similar to constructing a constrained positioning sequence. In this thesis, RdB are developed. The longest RdB sequences, not only have a highrate but also are generated and decoded rapidly. In summary, the contributions of this thesis are listed as follows:
Proposing a new kind of sequence (RdB), more efficient (higher rate, more general and adaptive) than HdB sequences.
Determining the length of the longest RdB sequences.
Determining the maximal asymptotic rate of RdB sequences.
Providing fast encoder and decoder based on state-of-the-art algorithms.
The rest of this thesis is organized as follows. Chapter 2 gives a brief introduc tion to coding theory and the application of de Bruijn sequences in such a researcharea. Other important results surrounding de Bruijn sequences and their general izations are also provided. Chapter 3 describes precisely the proposed run length limited de Bruijn sequence. For more understanding, the graph presentation of such sequences is presented. Chapter 4 studies the properties of the longest run length limited de Bruijn sequence. This chapter answers the major questions: Howlong is that sequence? What is its rate and maximal asymptotic rate? How to gen erate the longest run length limited de Bruijn sequence of order k? Also, how tolocate the position of each length ksub-string of such a sequence?The combinatorial object is one of the major focuses in coding theory, for instance, binary complementary sequences, Hadamard matrices, and de Bruijn se quences, . . . . Introduced in 1946, de Bruijn sequences have been well studied andapplied in various fields. This thesis is interested in its novel applications, synchro nization in quantum communication.
In this chapter, section 2.1 gives a brief introduction to coding theory. The de Bruijn sequence, its generalizations and applications are presented in section 2.2, 2.3,and 2.4. Finally, section 2.5 analyzes the de Bruijn based timing and synchroniza tion system proposed by Zhang, Oi, Lowndes, et al. The analysis points out that thecoding schema in such a system can be improved to achieve a higher rate. More over, it’s also necessary to design algorithms that help the system to encode and decode more efficiently.
2.1 Coding Theory
Transmitting, storing, protecting data (and so on) are challenging problems be cause of various factors: noisy channels, bandwidth, inter-symbol interference, . . .. Coding theory is the study of the properties of codes and their fitness thathelps dealing with these issues. In academic research, codes are involved in data transmission, data-storage, data-compression, cryptography, error-detection and correction.
2.1.1 Brief overview The article, ”A Mathematical Theory of Communication” by Claude Shannon, published in 1948, was considered to mark the birth of Coding Theory. In his work, Shannon showed that when a noisy communication channel is given, he defined a number, called the capacity of the channel, such that reliable communication can be achieved at any rate below the channel capacity if proper encoding and decoding techniques are used.
For more than half a century, coding theory has seen phenomenal growth. Manycodes have been well-studied and have various applications in real life. For exam ple, Reed-Solomon code is used in 3G, and 4G networks and Turbo code is used in 5G networks. Both Turbo code and LDPC code are channel coding techniques that Data modems, telephone transmission, and NASA Deep Space Network use to get the bit through.
Usually, coding is divided into source coding andchannel coding .Figure 2.1: Model of source and channel coding .
Source coding plays the role of changing the message source to a code that is suitable for transmitting through the channel. For example, ASCII code is a source coding standard converting each character to a byte of 8 bits is an example of source coding. Another way to think about source coding is to treat it as a compress-decompress process. At the transmitter, the source encoder compresses the message for the purpose of economizing on the length of the transmission. At the other end, the source decoder decompresses the received signal or sequence.
The commonly used compression algorithms include Huffman code used in JPEG, MPEG, MP3 files, Lempel-Ziv code used in ZIP files, . . . .
Because of physical and engineering limitations, channels are not ideal: their output may differ from their input because of noise or manufacturing defects. The transmitted message may become distorted and the receiver might not realize that the message was corrupted. Additionally, there are applications, such as magnetic and optical mass storage media, where certain patterns are not allowed to appear in the channel’s bit stream. The main role of channel coding is to overcome suchlimitations by encoding the message again after the source coding while maintain ing the channel as transparent as possible from the source and destination points of view.
Section 2.1.1 has introduced basic ideas of coding theory. In the next section, this thesis provides the commonly used notations and terminologies of this research field.
2.1.2 Notation and terminologies The most essential element of coding theory is codeword , which is a sequence of code symbols taken from a code alphabet q. The elements of Σare called code symbols, letters, and bits if q= 2. Aq-ary word of length nover Σis a sequence (or string) w=w1w2. . . w n∈Σnwith each wi∈Σfor all i.In practice, the size of a code alphabet is often the size of a finite field, which is the power of a prime number. Hence, for simplicity, Σcan be treated as a set of the first qnon-negative integers without ambiguity. More particularly, the notation Σ = 0 ,1,2, . . . , q −1can be used instead.
Definition 2 (Code and Codeword) .Aq-ary block code Cover Σis a nonempty set Cofq−arywords of the same length n. Each element of Cis called a codeword inC.
The study of a code Cinvolves the following process in an example of channelcoding. Suppose that ΣandΣ′are finite input and output of the channel respec tively. Let m, taken out of Mpossible information words, be a message input to the channel encoder. Through a desired channel encoder, the message mis mapped to a longer codeword c∈Σn. The word cis transmitted through the channel, become y∈Σ′n. After receiving y, the role of the channel decoder is to produce codewordˆcand a decoded information word ˆu, aiming to have c=ˆcandu=ˆu. Conse quently, the mapping at the channel encoder needs to be one-to-one, and the size Observe that, using code C, it takes a sequence of length nto encode a sequence to the message so that the channel can achieve its goal. Accordingly, a quantity concerning this redundancy was introduced, called (information) rate .
Definition 3 (Information rate) .The (information) rate of a code Cover an alpha bet of size qis defined as:
n. (2.1) Works in coding theory, including this thesis, are interested in designing codes with a high rate, along with efficient encoder, and decoder, that can be used in specific situations.
Based on their motive or their intrinsic properties, codes are categorized into ar codes, constrained codes, error-correcting codes, and error-detecting codes, . . .. This thesis focus on the combination of a constrained code, run length limited, and positioning code. A brief introduction to constrained code is given in the next section.2.1.3 Constrained codeConstrained Code is a sub-field of Coding theory, studies to design codes sat isfying given constrained. The inspiration for the research of constrained codescomes from real problems. The transmitted data needs to follow some given stan dards which are necessary for the code to surmount the flaw of the environment.
For instance, in CD disc storage, errors tend to occur when there is a sequence of many consecutive 0bits. Consequently, it’s crucial to construct codes that should avoid a long sequence of 0bits. A famous code invented to overcome this challengeis Run length limited code by Immink . RLL codes are defined by 2parame ters: d, k, and denoted by (d, k)-RLL, where dandkare two non-negative integers such that d⩽k. A finite length binary sequence is said to satisfy the (d, k)-RLL constraint if its number of 0’s between 2consecutive 1bits is at least dand at most k.
An illustration is a convenient way to begin understanding things. In constrained code, a graph, usually called a labeled graph, is a helpful visualization technique.
More particularly, a labeled graph is a directed graph with its vertices and edges labeled. Vertices in the labeled graph are also called states. And the start and end vertices of a directed edge are called initial and terminal states respectively. Given a state v, in-edges of vare edges treating vas a terminal state. Similarly, out-edges ofvare edges taking vas an initial state.
For example, the graph in figure 2.2 represents a (d, k)-RLL code. It can be verified that a sequence wsatisfies the (d, k)-RLL constraint if and only if a path whose edge labeling is wexists in the graph.
Figure 2.2: Graph representation of (d, k)-RLL code.
Labeled graphs are however more than just visualization tools. Using the finite state splitting algorithm, they become encoders. In a constrained system, a very common problem is designing an encoding algorithm, which maps arbitrary user sequences into sequences obeying the constraints. Nevertheless, it’s crucial to note that there are many kinds of encoders, depending on their objectives. For instance, there are encoders not taking any sequences as input, their goal is just to generatesequences satisfying given constraints. Such encoders are focused on in this thesis.Besides constrained code, another combinatorial object drawing much atten tions in coding theory is positioning code, also known by the name de Bruijn code.
The formal definition of this code and its important results are presented in the next section.
2.2 De Bruijn Sequence
A de Bruijn sequence (of order k), sometimes called a positioning sequence, over an alphabet Σ, is a sequence of symbols of Σsuch that all subsequences over Σof length kappear exactly once. This section first explains how to use a graph to represent de Bruijn sequences, and then introduces methods to generate or decode such sequences. Important results on the granddaddy, one of the most interesting de Bruijn sequences, which play a significant role in this work, are also given.
2.2.1 Graph presentation of de Bruijn sequences Since the first time introduced in 1946 by de Bruijn himself, the de Bruijn graphand its related sequences have been well-studied and generalized under numer ous names, including positioning sequences, m-sequences, shift register sequences –. The goal of de Bruijn was to find a recursive algorithm to enumerate the number of cyclic binary sequences of length 2ksuch that each binary k-tuple appears as a window of length kexactly once in each sequence.
The first results in the de Bruijn graph focused on the alphabet of size 2. Later, in 1951, van Aardenne-Ehrenfest and de Bruijn  generalized the enumeration result for any arbitrary alphabet of finite size q, using a generalized graph for an alphabet Σof size q.
Definition 4 (de Bruijn graph) .Formally, the de Bruijn Graph of order k,Gkis a directed graph with qk−1vertices, each one is represented by a word of length k−1over an alphabet Σwith qletters. A directed edge from the vertex x= (x0, x1, . . . , x k−2)to the vertex y= (y1, y2, . . . , y k−1), represented by the symbol xk, where xi, yi∈Σ, if and only if xi=yifor all 1⩽i⩽k−2. We call this edge xk the out-edge of x, and the in-edge of y. Progressively, the in-degree and out-degree of a vertex xare the numbers of in-edges and out-edges of xrespectively.
Deduced from the definition, the in-degree and out-degree of each vertex are q.
Thus, a de Bruijn graph is an Eulerian graph. Figure 2.3 gives an illustration for the graph G4.
Path : Apath in the graph is a sequence of edges: e0, e1, . . . , e nsuch that the terminal vertex of edge eiis the the initial vertex of edge ei+1for all 0⩽i⩽n−1.
Asimple path is a path going through each edge at most one time. Each longestFigure 2.3: de Bruijn graph of order 4,G4.
simple path in a de Bruijn graph is an Eulerian cycle. A sequence formed by con catenating the symbol of each edge in the longest simple path in Gkis called a (cyclic) de Bruijn sequence of order k. All the strings of length kappear exactlyonce in each such de Bruijn sequence. The acyclic version of the de Bruijn se quence can be obtained by prepending the sequence representing the first vertex in the corresponding Eulerian cycle to the cyclic one.
Example 2.1. Consider an Eulerian cycle starting at vertex 000, then the symbols representing the following edges 0,1,0,1,0,0,1,1,1,0,1,1,0,0,0form a de Bruijn sequence order 4. Adding 000to its beginning results in an acylic one:
0,0,0,0,1,0,1,0,0,1,1,1,0,1,1,0,0,0 .
The number of longest simple path in Gk, and also the number of de Bruijn sequences, have been proved in  to beq!qk−1 qk.
Example 2.2. Forq= 2, k= 4, there are 16distinct de Bruijn sequences. From figure 2.3, those de Bruijn sequences are found and listed as follows:0000100110101111 0000100111101011 0000101001101111 0000101001111011 0000101100111101 0000101101001111 0000101111001101 0000101111010011 0000110010111101 0000110100101111 0000110101111001 0000110111100101 0000111100101101 0000111101001011 0000111101011001 0000111101100101 2.2.2 Encode and decode de Bruijn sequencesEncoding de Bruijn sequences concerns generating an arbitrary de Bruijn se quence or a de Bruijn sequence satisfying some given constraints. Finding a de Bruijn sequence is equivalent to seeking an Eulerian cycle in a de Bruijn graph.
In , , efficient algorithms to find Eulerian cycles are presented. Especially,the approach in  can be used to generate all binary de Bruijn sequences. How ever, since the graph must be stored, applying such algorithms to find a positioning sequence requires exponential O(qk)space.
Besides the graph-based approach, there are other well-known methods to con struct such sequences, including LFSR, recursive methods, greedy methods, and concatenation approaches.
The idea of LFSR is to design a feedback function fmapping length kstrings to symbols of the current string to generate the next symbol until the maximal length polynomials generate maximal length sequences (positioning sequences) having length 2k−1that miss only the all 0string. The downside of this method is that it’s compulsory to find a primitive polynomial first.
De Bruijn sequences can also be constructed via recursion by applying Lempel’s amount of space is also required by these recursive strategies.
Surprisingly, greedy approaches are also able to generate de Bruijn sequences.
The greedy construction starts with a seed string, then repeatedly applies some greedy rule to determine the next symbol of a sequence. The algorithm stops when it is impossible to add another symbol without creating a duplicate substring of length k, or some termination condition is reached. The different explicit greedyrules result in different implementation greedy algorithms , –. Such constructions, however, have a major drawback: they require exponential space.
Despite many constructions being known, and even a useful survey has been given by Fredricksen , things are not quite the same for the decoding problem.
This problem, discovering the position within a particular sequence of any spec ified k-tuple, has been much less well studied. There are just some classical de Bruijn sequences with sub-ar decoding algorithm –.
2.2.3 Results on lexicographically minimal de Bruijn sequence The lexicographically minimal de Bruijn sequence, or granddaddy sequenceas called by Knuth , is one the most interesting among other de Bruijn se quences. An example of granddaddy is provided in example 2.3.
Example 2.3 (Granddaddy of order 6).
The encoding algorithm is actually a concatenation scheme, which is later called FKM algorithm, the abbreviation of Fredrickesen, Kessller, and Maiorana, who discovered this strategy , . Its complexity has been proved to be constant amortized time per symbol by Frank Ruskey et.al  in 1992.
Though its construction and the related algorithm has been found in 1978, about 40 years ago, the granddaddy’s decoder has just been discovered recently in 2016by Kociumaka, Radoszewski, and W. Rytter . Denote xas a granddaddy se quence of order k, and vis a length karbitrary substring. Then the decoding algorithm, denoted by DKRR, returns DKRR(v)being the one and only position ofvin the whole sequence x. Kociumala et.al also proved that DKRR works inO(k2log(q))-time in the word-RAM model and O(k2)-time in unit-cost RAM model.
2.3 Universal Cycles
A more general way to look at de Bruijn sequences is the universal cycle ( U cycle).
Definition 5 (Universal cycle) .Given a finite set Tkof distinct of combinatorial objects of ”rank k”, an U-cycle of Tkis a cyclic sequence U= (a0, a1, . . . , a n)such that(ai+1, . . . , a i+k),0⩽i⩽n, run through each element of Tk, where index addition is performed modulo n.An order kbinary de Bruijn sequence is eventually an U-cycle of the set of all length kbinary strings. The studies of U-cycle are concerned with the existenceand construction of U-cycles for many combinatorial objects such as strings, per mutations, partitions, subsets, multisets, lattice paths, vector spaces weak orders,etc –. Section 2.3.1 provides results for permutations, partitions, and sub sets of a set of ndistinct symbols, where nis a positive integer. These results were first summarized by Chung, Diaconis, and Graham in .
2.3.1 Permutations, partitions and subsets of ndistinct symbols n, setSnmay not always contain any U-cycles, such as n= 3. All 6permutations can travel is of length 4, for instance, 123→231→312→123, which still lacks 132,321.
However, if order-isomorphism is allowed instead of requiring exact matches, U-cycles of Snexists. More precisely, an U-cycle Un= (a0, a1, . . . , a n!−1),ai∈ to exactly one block (ai+1, . . . , a i+n), where ai=aj≡i( mod n!). Here, two n-tuples a= (a1, a2, . . . , a n)andb= (b1, b2, . . . , b n)are called order-isomorphic, written as a∼b, ifai< aj⇔bi< bjfor all 0< i, j⩽n. An example of U-cycle for S3is :
1 4 5 2 4 3 By order-isomorphism, each 3-tuple in the above U-cycles can be mapped into elements of S3as follow:
145∼123 452∼231 524∼312 243∼132 431∼312 314∼213 and hence, the equivalent cycle is 123→231→312→132→312→213→123.
The construction of de Bruijn graphs can be imitated to construct the transition graph for Sn. Each permutation plays the role of a vertex. Their suffix of length n− 1is analyzed to establish its edges to other permutations. Takes the vertex 231ofS3as an example. From its suffix 31, one can go to 312. But since order-isomorphism is accepted, and note that 31∼21∼32, there are also edges connecting 231to213 and321. The whole transition graph of S3is shown in figure 2.4.
Figure 2.4: Transition graph of S3.
It is proved that the transition graph of Snis Hamiltonian, and a Hamiltonian cycle in the transition graph corresponds to an U-cycle in Sn. Now, the key question is how to represent a U-cycle of an Hamiltonian cycle, like the sequence 1 4 5 2 4 3 represents 123→231→312→132→312→213→123. Even with S3, is5 the smallest number of distinct symbols necessary for an U-cycle. More generally, how many distinct symbols does an U-cycle of Snuse at least? Actually, in S3, one can do better with 4symbols. For example, the sequence 1 4 2 3 4 2 is the representation of a Hamiltonian cycle:
132→312→123→231→321→213→132 The following sequence is an example with 5symbols for S4:
1 2 3 4 1 2 5 3 4 1 5 3 2 1 4 5 3 2 4 1 3 2 5 4 LetN(n)be the minimum number required for an U-cycle of Sn, it is proved that:
N(2) = 2 , N(3) = 4 , N(4) = 5 and n+ 1⩽N(n)⩽6nforn⩾5 Fan Chung believes that the equation happens at n+ 1. However, their belief remains an unsolved conjecture until now.
Conjecture 1. N(n) =n+ 1.Constructing transition graph is also help finding U-cycle for the set of Pnof length n(a0, a1, . . . , a n), where ai=ajindicates the i-th element and j-th element are in the same group of the partition. The transition graph of Pnis illustrated in figure 2.5.
Figure 2.5: Transition graph of P3.
The transition graph of Pnis proved to be Hamiltonian by showing that it can be clustered to be an Eulerian graph.
It is more challenging to study the familyn kof all k-element subsets of a set of for the case n= 5, k= 2:
1 3 2 5 4 2 1 5 3 4 The question about the condition for the existence of the universal cycle forsuch a family is still not answered completely. The difficulty here is that a tran sition graph forn kisn’t able to be defined explicitly. This issue is caused by the distinguishing feature of an k-set. More precisely, a k-element subset might occur in any k!possible order in the U-cycle, but it is only allowed to occur once. Fan Chung and Graham made a conjecture on this problem and the first person who can solve it would earn a prize awarded by the author’s conjecture.
Conjecture 2 (Fan Chung’s conjecture) .Universal cycle fornkalways exists pro vided kdivides n−1 k−1 andnis large enough.
It’s easy to see that conjecture 2 is true for k= 1,2. Effort on this question has just cracked completely the cases k= 3,4,5(with some aid of a computer), and k= 6whenever nandkare relatively prime( , ). For k⩾7, and k= 6 when nandkare not relatively prime, conjecture 2 remains open.
Besides studying the existence of U-cycle on different kinds of sets, designingalgorithms that create universal cycles is also concerned.
2.3.2 Universal cycles algorithms for other classes of sets There are researches focusing on using generalized the FKM algorithm and greedy algorithm to create universal cycles for a class of sets. Moreno proved that this method works for the set of rotations of the lexicographically largest i necklace . The aperiodic strings in the set of all k-ary strings of length ncanbe generated the same way as shown by Au in . All these results are later gen eralized by Joe Sawada et.al in . More particularly, let Sbe the set of length n k-ary strings such that the following closure conditions are obeyed:
The set of strings Sis closed under rotation.
Its subset of necklaces is closed under replacing any suffix of length ibyki.
Then, the greedy and FKM algorithm create the lexicographically smallest uni versal cycle of S. Several such classes Sare listed in example 2.4.
q is the set of q-ary sequences of length nover alphabet Σ. The following sets satisfy the closure conditions for the existence of universal cycles proved by Sawada .
Minimum Sum :S∈Σn qis a set of length nstrings with sum over all of its symbol at least s, where sis a given constant.
Frequency of q:S∈Σn qcontains the strings with at least lqcopies of q, where lqis a given constant.
Frequency of i < q :S∈Σn qcontains the strings with at most uicopies of i < q . Here, uiis a given constant.
Avoiding a substring :S∈Σn qcontains the strings that do not contain a given q−1, for some m⩾1, as a cyclic substring.
Union and Intersection : Let S1andS2be2set obeying the closure condi tions, then both S1∪S2andS1∩S2also satisfy those conditions.
Note that, in example 2.4, the union and intersection of the proper sets Sallow to combine the previous results to create more interesting classes of sets that have universal cycles.
Section 2.3 has provides different research directions and results on the univer sal cycle, which is a generalization of de Bruijn sequences. The applications of de Bruijn sequences and their generalizations will be presented in the next section.2.4 Applications The reason why the de Bruijn graph, its sequence, and its generalizations are having so much attention is due to their diverse important applications. Very soon after the formal definition of this graph was given birth, one of its first applicationswas found in the introduction of shift-register sequences in general and ar feed back registers in particular . Throughout the years, these types of sequences and graphs have found a variety of applications.
In cryptography, for example, the Baltimore Hilton Inn used de Bruijn sequences to install a cipher lock system for each of its rooms in lieu of the conventional key-lock system . The low-cost n-stage shift register was used to generate maximum-length pseudorandom sequences in stream cipher, though later, this method was proved to be vulnerable to known-plaintext attack .
De Bruijn sequences also opened a new field of research surrounding their com plexity. Agnes Hui Chan et.al studied the complexity and the distribution of the complexities of de Bruijn sequences . Especially, for binary sequences withperiod 2n, they come up with a fast algorithm determining its complexity . Ed win on himself analyzed the structure and complexity of nonar binary sequence generators . Tuvi et.al studied the error ar complexity spectrum of binary sequences with period 2n. Also Tuvi, in his joint work with Lampel , found a construction of the de Bruijn sequence to show that the lower bound of its complexity ( 2n−1+n) is attainable for all n.
In , A.Lampel and M.Cohn are interested in designing a universal test se quence for VLSI (very large-scale integration chip). A binary sequence is called (s, t)-universal, s > t , if when shifted through a register of length s, it exercises every subset of tregister positions. Their proposed method was concatenating a set of de Bruijn sequences of appropriate length. In , Zeev Barzilai .et.al also demonstrated an application of de Bruijn sequence in VLSI self-testing.
There are also other applications requiring a two-dimensional version of de Bruijn sequences. And the research about the two-dimensional generalization of de Bruijn sequences comes to call. One well-known version is called pseudo-random arrays. In 1976, Mac Williams and Neil Sloane  gave a simple description of pseudo-random arrays and studied several of their nice properties. In 1988,Tuvi , represented a new version of pseudo-random arrays to construct per fect maps. In another approach by Bruck Stein , he combined a de Bruijnsequence and a half de Bruijn sequence to study its robust and self-location prop erties. Studies – used pseudo-random arrays to with applications to robustundetectable digital watermarking of two-dimensional test images, and structured light.
More surprisingly, de Bruijn’s modern applications are even combined with bi ology, like genome assembly as part of DNA sequencing. For example, Chaisson et.al  described a new tool, EULER-USR, for assembling mate-paired shortreads and used it to analyze the question of whether the read length matters. Compeau et.al  represented a method using the de Bruijn graph for genome assembly. In 2001, Pevzner et.al  abandoned the classical “overlap - layout  consensus” approach in favor of a new Eulerian Superpath approach, that, for the first time, resolves the problem of repeats in fragment assembly. Later on, in 2003,Yu Zhang and Michael Waterman , adapted Pevzner’s method to global mul tiple alignment for DNA sequences. In DNA storage, Han Mao et.al ,  studied codes and their rates for DNA sequence profiles. Their studies were based on the de Brujn graph.
In some new memory technologies, mainly in racetrack memories, and other ones which can be viewed as an l-read channel, synchronization errors (which are shift errors known also as deletions and sticky insertions) occur. By proposing a new de Bruijn-based schema, using a locally-constrained de Bruijn sequence to construct such code, Chee et.al.  are able to increase the rate of codes that correct the synchronization errors. Locally constrained de Bruijn sequences and codes (sets of sequences) are of interest in their own right from both practical and theoretical points of view.
Recently, in 2021, a novel application of the de Bruijn sequence has been found in quantum communication. Generally, to transmit quantum information between a satellite and the ground station, a timing and synchronization system has been used. Having observed that the intrinsic properties of the positioning sequence are very suitable for this system, Zhang, Oi, Lowndes, et al.  have modulated it into HdB sequence to transmit along the quantum channel. Their system is analyzed in the next section.
2.5 Motivation
In satellite QKD, the quantum information is synchronized by transmitting along with the classical one. Figure 2.6 shows a high-level view of this schematic.
At the beacon source, a de Bruijn sequence is modulated before transmitting to the ground.
The encode process happens at the satellite, where it uses the LFSR algorithmFigure 2.6: High-level satellite Quantum Key Distribution timing and synchronization schematic .
to generate a positioning sequence (of order kfor example). The prerequisite of finding a proper primitive polynomial is the main drawback of this encoder.
The decoding process takes place at the ground station, a look-up table is used to identify the unique position of the received sequences of length k. The complexity of this method is exponential.
Furthermore, in this model, a sequence of beacon pulses is used to represent a binary de Bruijn sequence. Considering the timing jitter performance, a long period of no-pulses should be forbidden. If one pulse slot is used to represent a binary bit, for example, on is 1 and off is 0, a long run of 0’s in the sequence (which is a long period of no-pulses) would impact the timing jitter. In , two pulse slots are used to represent a single bit (on-on is 1 and on-off is 0) so that one can avoid two consecutive no-pulses. The transmitted sequence is called HdB. However, the above scheme requires 2npulse slots to represent a de Bruijn sequence of length nand needs to receive a sub-sequence of 2 lognpulse slots to locate its position.
Formally, the HdB sequence’s rate is just 0.5, where rate is a quantity that needs to be as high as possible (the definition of sequences’ rate is given in section 4.2).
Table 2.1 summarized the process, applied methods and drawbacks of dBTS system using HdB sequence.
This thesis’s target is to surmount the drawbacks listed above.
In order to avoid long period of no pulse, the positioning sequences are com bined with run length limited constraints. Such sequences are called Run length limited de Bruijn (RdB) sequences, presented in chapter 3. The RdB sequencesare not just suitable with dBTS system, but also have a higher rate than HdB se quences. More precisely, rate of the longest RdB sequences are log 2Table 2.1: Timing and synchronizing system use Hybrid de Bruijn code.
Satellite Transmited de Bruijn sequenceGround StationRequirement : transmit a de Bruijn se quence of order kRequirement : be able to be positioned, avoid periods of no-pulseRequirement : locate the position of any length ksubsequence Method : use linear feedback shift register algorithmMethod : modulate on-on is 1, on-off is 0Method : use look-up tableDrawback : the pre requisite of finding aproper primitive polynomialDrawback : rate is 0.5Drawback : exponen tial complexity So as to generate one of the longest RdB sequences, based on FKM algorithm, chapter 4 provides an encoder whose time complexity is constant amortized time per symbol. Moreover, to locate the position of an arbitrary proper subsequence in the whole RdB sequence, a decoder is also presented. The proposed decoder modifies the decoding algorithm found by Kociumaka, Radoszewski, and Rytter in , which is currently the state of the art method to position a subsequence in the de Bruijn sequence, and therefore, is better than look-up table.
Beside, the RdB sequence is even more general and adaptive. More particularly, when the constraint of forbidding pattern 00is relaxed, that is, a longer run of bit 0’s is allowed, the RdB sequence can be easily adjusted to make the its rate higher and still suits the system.In this chapter, new constrained de Bruijn sequences are introduced. Since a de Bruijn sequence is self-located, the run length limited constraint is the only requirement remaining that this sequence needs to satisfy to be used in the dBTS system. Therefore, combining a positioning sequence and a run length limited sequence is a natural solution. That is also how this thesis gave birth to the name:
Run length limited de Bruijn sequence. Besides, just like other constrained codes, a convenient way to apprehend a code is using a labeled graph. Hence, the graph presentation of these sequences is also provided.
3.1 Run length limited de Bruijn sequence
bet of size q. Asequence s= (s1, s2, . . . , s n)∈Σn qis over an alphabet Σ, that is, si∈Σq. This thesis only focuses on the case q= 2and thus drops qin the notation for simplicity. Sequence s=s1s2. . . s n∈Σnis also written without ambiguity.
The window (substring) (si, si+1, . . . , s j)is denoted by s[i, j].
Given two sequences x=x1x2. . . x mandy=y1y2. . . y n, denote the concatena tion of xandyto be xy=x1x2. . . x my1y2. . . y n, and denote xkthe concatenation ofkcopies of x. It is said that xis smaller than y, denoted x<y, if there is an index t⩾1, such that xi=yi,∀i⩽t, and xt+1< yt+1. Note that empty sequence is smaller than 0.
Definition 6. A sequence s= (s1, s2, . . . , s n)is called a s-run length limited (RLL) sequence of length nif each run of 0’s in the sequence shas length at most s, or in other words, the sequence sdoes not contain s+ 1consecutive 0’s as a substring.
A set of s-RLL sequences of length nis called a s-RLL code and denoted C(n, s).
Denote W(n, s)the set of all s-RLL sequences of length nand note that W(n, s) has been well-studied in the literature , . This thesis presents the recursive Lemma 1 (Cardinality of W(n, s)).Letn, sbe two non-negative integers. Then Proof. For the first equation, when n⩽s, all sequences of length nbelong toWhen n > s , every sequence in W(n, s)is of the form 0i1x, where x∈W(n− i−1, s)for0⩽i⩽s. Additionally, for every x∈W(n−i−1, s), the sequence 0i1xis an element of W(n, s). This bijection brings the second equation.
crossed cell of column n=iwith row s=j.
Table 3.1: Values of W(n, s)for all n=0,12ands=1,9.
sn01234 5 6 7 8 9 10 11 12 1 1235813 21 34 55 89 144 233 377 2 124713 24 44 81 149 274 504 927 1705 3 124815 29 56 108 208 401 773 1490 2872 4 124816 31 61 120 236 464 912 1793 3525 5 124816 32 63 125 248 492 976 1936 3840 6 124816 32 64 127 253 504 1004 2000 3984 7 124816 32 64 128 255 509 1016 2028 4048 8 124816 32 64 128 256 511 1021 2040 4076 9 124816 32 64 128 256 512 1023 2045 4088 Definition 7 (Run length limited de Bruijn (RdB) sequence) .A sequence s= (s1, s2, . . . , s n)∈Σnis called a (k, s)-run length limited de Bruijn (RdB) sequence of length nif it is a de Bruijn sequence of order kand a s-RLL sequence of length n.
Example 3.1 gives an instance of RdB sequence.
Example 3.1 ((5,2)-RdB sequence) .Fork= 5, s= 2, a(5,2)-RdB sequence of length 27iss= (0,0,1,1,0,0,1,0,1,0,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,0,0).
Note that, when s⩾k, a(k, s)-RdB sequence is just an original de Bruijn sequence. If s=k−1, any (k, k−1)-RdB sequence can be achieved from a de Bruijn sequence removing 1letter 0in the subsequence 0k. Based on those observations, case s⩾k−1is considered to be trivial. Therefore, this thesis concentrates on the case s < k−1. And thus, in the rest of this thesis, sis always assumed to be smaller than k−1.
It is well-known that given k, the maximal length nof a binary acyclic de Bruijn sequence is n= 2k+k−1. Let N(k, s)be the maximal length of a (k, s)-RdBsequence. This thesis is interested in finding the exact value of N(k, s). The moti vation of this task is explained clearly in section 4.2, which concerns the rate of a sequence.For further demonstration, the next section presents the graph presentation for the(k, s)-RdB sequence.
3.2 Graph presentation of RdB sequence
In this section, a labeled graph, called (k, s)-RdB graph, is used to represent (k, s)-RdB sequences. Just like a de Bruijn graph of order k, any simple path in (k, s)-Rdb graph represents a (k, s)-RdB sequence.
A(k, s)-RdB graph can be achieved by eliminating all the vertices containing more than sconsecutive letter 0in the de Bruijn graph Gk. As a result, the vertices of a(k, s)-RdB graph are represented by binary sequences of length k−1which don’t contain pattern 0s+1.
The illustration for de Bruijn graph of order 4,G4, was given in figure 2.3. To obtain (4,1)-Rdb graph from there, vertices 000,001,100are deleted. Figure 3.1 demonstrates the (4,1)-RdB graph.
Figure 3.1: (4,1)-RdB graph.
Denote the (k, s)-RdB graph to be Gk,s= (Vk−1,s, Ek,s), where Vk−1,sis the set of all vertices and Ek,sis the set of all edges. The following lemmas determining the cardinality of Vk−1,sandEk,s Lemma 2 (Number of vertices ).
Proof. This proof is deduced directly from the construction of Gk,ssince its set of all vertices is the set of all length k−1sequences containing at most sconsecutive letters 0.
Lemma 3 (Number of edges ).Proof. Observe that for both x,y∈W(k−1, s), if there is an edge from vertex x= (x1, . . . , x k−1)to vertex y=y1, . . . , y k−1, then (x1, . . . , x k−1, yk−1)∈W(k, s).
Besides, for each s-RLL sequence x= (x1, . . . , x k)∈W(k, s), its prefix and suffix, (x1, . . . , x k−1)and(x2, . . . , x k), are both s-RLL sequence of length k−1.
Hence, they represent two vertices in the graph Gk,sand their connecting edge is represented by the sequence x.
Example 3.2. According to lemma 2 and lemma 3, (4,1)-RdB graph hasV3,1= the number of vertices and edges in figure 3.1.
Letu= (u1, u2, . . . , u k−1)andv= (v1, v2, . . . , v k−1)be arbitrary vertices in RdB graph. Starting at v, the following sequence of edges’ labels (1, u1, u2, . . . , u k−1) apparently forms a proper path going from vtouin RdB graph. Similarly, the sequence of edges’ labels (1, v1, v2, . . . , v k−1)beginning at uis also a directed path from utov. This is sufficient to conclude that the connectivity of RdB graphs is preserved.SEQUENCE Chapter 4 concerns in determining the rate of RdB sequence. Besides, designingefficient encoder and decoder for a longest RdB sequence are also critical contri butions.
To calculate the rate and maximal asymptotic rate of RdB sequence, first, resultson the maximal length of a RdB sequence are presented. After that, efficient al gorithms to generate a longest RdB sequence and locate any sub-sequence in such sequence are also provided.
4.1 Longest simple path in RdB graph
The rate of de Bruijn sequences can be determined by understanding its longest length. Section 4.2 provides a formal definition of rate and maximal asymptotic rate of the de Bruijn sequence. This section concerns finding the longest simple path in Gk,s, which corresponds to the longest (k, s)-RdB sequence.
LetN(k, s)is the maximal length of a (k, s)-RdB sequence, and ℓ(Gk,s)be the length of the longest simple path in Gk,s. Recall that a length lsimple path in Gk,s is equivalent to a (k, s)-RdB sequence of length l+k−1. Therefore, N(k, s) = ℓ(Gk,s) +k−1.
The de Bruijn graph Gkis actually an Eulerian graph because each vertex has exactly two in-coming edges and two out-coming edges. This results in its longest path visiting each edge exactly once and has a length of 2k. However, (k, s)-RdB graph Gk,sdoesn’t have the same property since the in-degree and out-degree of each vertex can be one or two. Thus, a simple path that visits all edges of the graph may not exist.
To overcome this issue, the upper bound U(k, s)for the length of the longest simple path is first determined in this section. Then, U(k, s) =U(k, s) +k−1 is the upper bound for the length of longest (k, s)-RdB sequence. This work later proves that such bound can be achieved by proposing an efficient encoder returning a sequence of length U(k, s)in section 4.3.1. Hence, it’s sufficient to conclude that the upper bound U(k, s)is also the length of the longest simple path. In other words, ℓ(Gk,s) =U(k, s), and N(k, s) =U(k, s) Before deriving the explicit formula of maximal length, it’s necessary to analyze more meticulously the in-degree and out-degree of all vertices. Given 0⩽i, j⩽s, define:Vk−1,s i,j=n x:x∈Vk−1,s,x[1, i+ 1] = 0i1, x[k−1−j, k−1] = 10jo That is, Vk−1,s i,j is the set of all vertices in Gk,ssatisfying the first i+ 1letters are (0,0, . . . , 0,1)and the last j+ 1letters are (1,0,0, . . . , 0). Lemma 4 summaries the properties of Vk−1,s i,j the helps finding U(k, s).
Lemma 4 (Properties of Vk−1,s i,j )..
1.Vk−1,s 2.P 0⩽i,j⩽sVk−1,s 3. The in-degree and out-degree of each vertex in Vk−1,s s,S(ifVk−1,s s,s̸=∅) is exactly 1.
4. The in-degree and out-degree of each vertex in Vk−1,s i,j is exactly 1for all 0⩽ i, j⩽s−1.
5. For each vertex in Vk−1,s s,i(0⩽i⩽s−1), their in-degree is exactly one and their out-degree is exactly two.
6. For each vertex in Vk−1,s i,s(0⩽i⩽s−1), their in-degree is exactly two and their out-degree is exactly one.
Proof. .
1. For each element x∈Vk−1,s i,j , its subsequence, x[i+ 1, k−2−j], can be any sequence of length k−i−j−3such that more than sconsecutive letter 0’s is forbidden. Hence x[i+ 1, k−2−j]∈W(k−i−j−3, s). Reversely, given an arbitrary sequence y∈W(k−i−j−3, s), the string 0i1y10jis a sequence inVk−1,s i,j . It comes to the conclusion that there is a bijection from Vk−1,s i,j to W(k−i−j−3, s). In other word,Vk−1,s 2. Since Vk−1,s i,j∪Vk−1,s i′,j′=∅with (i, j)̸= (i′, j′), and i, jcannot exceed s, thus, P 0⩽i,j⩽sVk−1,s i,j=Vk−1,s.
3. The properties from (3)to(6)can be deduced directly by considering the prefix and suffix of each element in those sets.
Theorem1 (Longest simple path ).LetC= min ( s−1, k−s−2). The length ofthe longest path in Gk,s,ℓ(Gk,s), is equal to U(k, s), where:
(4.1) As mentioned above, proof of theorem 1 is divided into 2 parts. While the first one claims ℓ(Gk,s)⩽U(k, s), the second one shows that there exists a sequence can achieve the length of U(k, s)+k−1. This section provides the proof of the first part (lemma 5). Proof for the second part is available in section 4.3.
Lemma 5. The longest simple path in Gk,s’s length cannot exceed U(k, s), that is, ℓ(k, s)⩽U(k, s).
The following definitions and claims are essential to prove lemma 5.
Definition 8 (Balance and unbalanced vertex) .A vertex with the quantity of in coming edge equal to the quantity of out-coming edge is called a balanced vertex.
A vertex is left-unbalanced if it has 2edges coming in and 1edges coming out.
Reversely, a vertex is right-unbalanced if it has 1edge coming in and 2edges coming out.
Recall that a path is defined to be a sequence of edges. A vertex vis said to be (lying) in or belong to a path P, denoted by v∈P, ifvhas edges in P. It’s also fair to say that Pgoes through v. Besides, vis called the end (or the start) vertex ofPif its last (first) edge ends (begins) at v.
Suppose Pto be a longest simple path in Gk,s. In other word, Pachieves the length ℓ(Gk,s). Some observations about Pare given in the following claims.
Claim 1. All the vertices in P, if not a start or end vertex, must have the number of in-edges and out-edges equal in P.
Proof. Letvbe a vertex in P,vis neither start nor end vertex. Then whenever P comes to vby an in-edge, it must go out of vby an out-edge. So the claim 1 is true.
Claim 2. Every balance vertex in Phas their quantity of in-edges and out-edges inPequal, even if one of them is the start or end vertex.
Proof. Letvbe a balanced vertex and Pgoes through v. Ifvis neither end nor start vertex, by claim 2, vhas the number of in-edges and out-edges in Pequal.
Without loss of generality, assume that vis the start vertex. This results in the number of out-edges of vbeing equal or has 1edges more than its number of out-edges. If these two quantities are equal, the proof is done. Otherwise, denote e′to ate′is a proper simple path RdB graph, but longer than P, which contradicts to the assumption about the longest property of P.
Claim 3. Letu= 0s1x1t0jbe a right-unbalanced vertex. Then the shortest path going from uto an arbitrary left-unbalanced vertex lengthen s−j.
Proof. A left-unbalanced vertex is represented by a sequence whose suffix of length sis filled by 0. Hence, a path from uto a left-unbalanced vertex must contain atleast s−jedges labeled 0. In fact, a path of length s−jconnecting uto a left unbalanced vertex exists, which is the path of all 0labeled edges. This path comes from uto0s−j1x1t0s.
Proof for lemma 5. Define 1x1tto be a sequence of length tsuch that start and end letters are both 1. Let L=C[ j=0 u:u= 0j1x1t0s, s+t+j=k−1 be the set of all left-unbalanced vertices Letv= 0j1x1t0sbe an arbitrary vertex in Lsuch that visn’t the end-vertex of pathP.
1. It can be proved that there is a path Pvof length s−jsatisfying all of its edges not lying in Pand its end-vertex is v. The path Pvis constructed backwardly as follows:
Starts with Pv=∅. As vhas2in-edges and 1out-edges, there’s at least 1 in-edge evofvnot lying in P. Of course, ev’s label is 0. Adds evtoPv. Let Continue adding this edge to the head of Pv. Denote a2a10j1x10s−2to be the initial state of this edge. Now, Pvcan be represented as below:
Pv=  a2a10j1x1t0s−2, a10j1x1t0s−1   a10j1x1t0s−1,0j1x1t0s Assume inductively that:Pv=h al···a2a10j1x1t0s−l, al−1···a10j1x1t0s−(l−1) ···,   a2a10j1x1t0s−2, a10j−11x1t0s−1    a10j−11x1t0s−1,0j1x1t0si with l⩽s−j.
Ifl=s−j, the proof is done. Otherwise, it’s obvious that al···a2a10j1x1t0s−l is balance, hence, by claim 2, it also has at least 1in-edge not lying in P, and one can continue adding such edge to the head of Pv.
2. It can be shown that for each u, v∈Lsuch that neither unorvis the end vertex of the last edge of P, paths PuandPvare edge-disjoint.
Represent Pu= [eu,1, eu,2,···, eu,i],Pv= [ev,1, ev,2,···, ev,j]. Assume to the contrary that ∃t⩽i, l⩽jsatisfying eu,t=ev,l. Without loss of generalization, we suppose that i−t⩽j−l. As all edges in PuandPvare labeled 0, we must have eu,t+1=ev,l+1,···, eu,i=ev,l+(i−t).
Ifl+i−t=j, we have PuandPvhave the same last edge but different terminal states, which is impossible. Otherwise, the path ev,l+i−t+1,···, ev,jis the path connecting utov. But the length of this path is smaller than s, which is also absurd.
Summary, for each vertex in Lsuch that visn’t the end-vertex of the last edge in pathP, there is a path Pvof length s−jsatisfying all of its edges not lying in P and takes vto be its end-vertex. Moreover, all these such paths are edge-disjoint, and there can be only 1end-vertex of the last edge in path ℓ(Gk,s), the total edgesof all such path Puis:
CX =CX ⩾CX This means at leastPC can not exceed :
This concludes our lemma.
Define U(k, s) =U(k, s)+(k−1), thenU(k, s)is length of the longest (k, s)-RdB sequence.
4.2 Rate and maximal asymptotic rate of (k, s)-RdB sequence
For every (k, s)-RdB sequence, their rate is defined as follows:
Definition 9 (Rate) .Denote R(xk,s)to be the rate of a (k, s)-RdB sequence xk,s, then:
R(xk,s) =log xk,s k(4.2)The rates of sequences are the proportion of the data stream that is useful (non redundant), which tell how much useful information is transmitted. The sequence’s rate actually originates from the information rate. Recall that, in definition 3, the n. If a (k, s)-RdB sequence xk,sis considered to be a code Ck,s, each of its size kwindows is treated as a codeword. The size of Ck,sis exactly the length of xk,sminus k, butthe offset kcan be omitted under log calculation. Hence:
RCk,s=logq Ck,s n=log(xk,s) k=R(xk,s) . That is to say, R(xk,s)is eventually a kind of information rate.
Note that, a high rate is usually preferred. Accordingly, with each given pair (k, s), the maximal rate of all (k, s)-RdB sequence is defined.
Definition 10 (Maximal rate) .Given kands, the maximal rate Rk,sof all (k, s) RdB sequences is:
Rk,s=log(N(k, s)) k(4.3) The maximal asymptotic rate is concerned in case kappears to be very large.
Definition 11 (Maximal asymptotic rate) .Denote Rsto be the maximal asymptotic rate of (k, s)-RdB sequences, then:
Rs= lim k(4.4) Having the explicit formula of N(k, s)determined makes it easier to calculate the maximal asymptotic rate of the (k, s)-RdB sequence. The following equation is a direct consequence of theorem 1:
+k−1 (4.5) Theorem 2 below shows that the rate of (k,1)-RdB sequence is better than therate of HdB sequence. Therefore, it’s able to use (k,1)-RdB sequence for the sys tem in  instead to increase the rate, speed of encoding, and decoding of the transmitted signals.
Theorem2.consequently, it’s able to write:
( As a result:
=  And hence:
R1= lim k = lim 5+k k xs+1−xs−. . .−x−1 = 0 (4.7) this is proved to be true in the following theorem, the generalization of theorem 2.
Theorem3 (Maximal asymptotic rate of RdB sequence) .Letsbe a positive integer.
Then:
positive roots of 4.7 lying in the interval (1,2), the other roots are in the open diskfollows:
whereas ais a positive constant. Thus, from expression 4.5:
+k−1 This results in:
Rk= lim k = lim k+ lim k s 1 2 3 4 5 6 7 8 ofRk,swith k=2,4and then increase to the large k=71,74.
4.3 Construction of RdB sequence
This section presents a construction of a (k, s)-RdB sequence ck,s. Furthermore, given a substring of length kof the sequence ck,s, a fast decoding algorithm to determine the location of the given substring is provided. The complexity of the decoding algorithm is sub-ar with respect to the length of ck,s. There are some1 1 0.9358 0.8649 . . . 0.6942 0.6942 0.6942 0.6942 2 1.1610 1.0566 1 . . . 0.8791 0.8791 0.8791 0.8791 3 1.1610 1.1073 1.0425 . . . 0.9468 0.9468 0.9468 0.9468 4 1.1610 1.1073 1.0620 . . . 0.9752 0.9752 0.9752 0.9752 5 1.1610 1.1073 1.0620 . . . 0.9881 0.9881 0.9881 0.9881 6 1.1610 1.1073 1.0620 . . . 0.9942 0.9942 0.9942 0.9942 7 1.1610 1.1073 1.0620 . . . 0.9971 0.9971 0.9971 0.9971 8 1.1610 1.1073 1.0620 . . . 0.9986 0.9986 0.9986 0.9986 Table 4.2: The convergence of Rk,s with sfrom 1to8 classical de Bruijn sequences with sub-ar decoding algorithm –. This work uses the minimal de Bruijn sequence, constructed in , , and some special properties of Lyndon words to construct a (k, s)-RdB.
Definition 12 (Lyndon words ).A sequence wis a Lyndon word if and only if it’s strictly smaller than all of its rotation.
For more intelligible, several Lyndon words and non-Lyndon words are pro vided in example 4.1.
Example 4.1 (Lyndon words) .The word 00101 is a Lyndon word since it is smaller than all of its rotations: 01010 ,10100 ,01001 ,10010 . The word 01100 is not a Lyndon word, since one of its rotations, 00011 , is smaller than it. The word 011011 is also not a Lyndon word, as its cyclic rotation by 3letters is equal to it.
4.3.1 Encoder for a (k, s)-RdB sequenceIn 1978, Fredricksen and Maiorana  proposed the FKM algorithm to effi ciently construct the lexicographically minimal de Bruijn sequence, which is later called the granddaddy sequence by Knuth . The algorithm was based on their finding of the connection between the de Bruijn sequence and Lyndon words.
Lemma 6 () .The lexicographically minimal de Bruijn sequence of order k (k-MdB) is the concatenation of all Lyndon words whose length is a divisor of kin the lexicographical order.
For example, the 6-MdB sequence is decomposed into Lyndon words as follows:
Example 4.2 (Decomposition of 6-MdB sequence) .Recall that 6-MdB sequenceAs stated in lemma 6, it can be decomposed in lexicographically order into Lyndon words listed follows: 000101 001 001101 01 011 1 This thesis observes that it is able to append a prefix to a suffix of k-MdB to obtain a (k, s)-RdB sequence, i.e., in the cycle representing k-MdB, there are arcsrepresenting (k, s)-RdB sequences. To illustrate this idea, figure 4.1 gives an ex ample for k= 6ands= 2, where the blue arc and the red arc indicate the prefix and the suffix respectively. Any substring of the concatenation of the prefix and suffix is a (6,2)-RdB sequence.
More precisely, the construction is described as follows:
Construction 1. Letx= (x1, . . . , x n)be the k-MdB constructed from Lemma 6 anduk,s= 0s+11k−s−1be a Lyndon word of length ksatisfying the first s+ 1letters are all 0’s and the last k−s−1letters are all 1’s. By the intrinsic property of de Bruijn sequences, there exists only one index isuch that uk,s=x[i, i+k−1] = (xi, . . . , x i+k−1). Denote the word ck,s= (xi+1, . . . , x n,0,0, . . . , 0), obtained by adding sletters 0to the end of the suffix of x, from index i+1to the end. Theorem 4 below claims that ck,sis a(k, s)-RdB sequence.
This thesis later proves that ck,sis even the longest (k, s)-RdB sequence.Figure 4.1: Example for k= 6, s= 2. In the circle of 6-MdB, an arbitrary substring of the concatenation of suffix and prefix in the picture is a (6,2)-RdB sequence.
be the set of all Lyndon words whose lengths are divisors of n. The formal encoder to construct a (k, s)-RdB sequence is given in algorithm 1.
Algorithm 1: Encode (k,s)-RLL dBs Input : k, and descending ordered set Ł(n).
Output: (k, s)-RLL dBs w←emptystring /*remove the first letter of w, which is 0, and add sletters 0to the end */ w=w[2, ℓ]0s break return w The set Ł(n)in lexicographically order can be generated in constant amortizedtime by applying FKM algorithm (analyzed in ), or by another algorithm devel oped by Duval in . In algorithm 1, the most consuming time step is to produce the set Ł(n), and hence, its complexity is the complexity of the algorithm used to bring out Ł(n).
Here presents an example for k= 6ands= 2.Example 4.3 (Construction of (6,2)-RdB sequence) .The suffix:
00111 001011 001101 001111 01 010111 011 011111 1 is taken from the granddaddy of order 6given above. Adding 2letter 0to the end of it obtains:
00111 00 001011 001101 001111 01 010111 011 011111 1 00 which is indeed a (6,2)-RdB sequence.
Now, theorem 4 proves that the Construction 1 always return a (k, s)-RdB se quence.
Theorem 4. The sequence ck,sobtained from Construction 1 is a (k, s)-RdB se quence.
Proof. First, it’s necessary to show that each substring of length kappears at most once in ck,s. Note that the granddaddy sequence xobtained from Lemma 6 is a cyclic de Bruijn sequence, and ck,sis actually a substring of x. Hence, ck,sjust contains each substring of size kat most once.
Now, claiming that ck,sdoesn’t contain any patterns 0s+1will complete the theo rem. This can be proved by considering the property of Lyndon words. It’s obviousto see that uk,s= 0s+11k−s−1is the largest Lyndon word containing s+ 1consecu tive symbols 0. Hence, every Lyndon word decomposed from ck,sdoesn’t take 0s+1 as a substring. Moreover, the last symbol of all Lyndon words but 0is1. Therefore, 0s+1will not appear in the combination of Lyndon words larger than uk,s. Adding 0s1k−s−1to the beginning and sletters 0to the end of this combination resulting inck,swon’t change this property. So, it’s able to conclude that ck,sis indeed a (k, s)-RdB sequence.
4.3.2 Decoder for a (k, s)-RdB sequence In , the Hybrid de Bruijn sequence of order kafter being received needs to be decoded for correcting errors. More particularly, it’s necessary to indicate the exact location of an arbitrary sequence of length kin the Hybrid de Bruijn sequence. To do that, they proposed to use a look-up table, which is an exponential complex method.
Similarly, it’s essential for this work to decode ck,s. In 2016, Kociumaka, Ra doszewski, and Rytter presented the first sub-ar decoding algorithm DKRR for the minimal de Bruijn sequences. And since ck,sis a substring of a minimal deBruijn sequence, it’s able to modify DKRR to decode ck,sin sub-ar time.
Leti=DKRR(uk,s)be the position of the word uk,sin the granddaddy sequence of order kx. Recall that, from Construction 1, we have ck,s= (xi+1, . . . , x n,0s).
Thus, for each length kword vlying in ck,s, its location in ck,sis to location of v inxminus j, unless they are of the form 1j0k−jfor all 1⩽j⩽swhich appear at the end of ck,s. The formal description of our decoding algorithm is shown in algorithm 2.
Algorithm 2: Decode (k,s)-RdB ck,s Input : A word v= (v1, . . . , v k)of length k Output: a is the location of vinck,s i← D KRR(uk,s); /*DKRR is the decoder of the minimal de Bruijn sequence in  */ ifv= 1j0k−j,then return n−i+ 1−(k−j); else return DKRR(v)−i; 4.3.3 The optimality of our construction This section gives proof for the claim stated in section 4.1, that is, the encoder produces sequence ck,swhose length equals to to upper bound U(k, s), and thus, ck,sis the longest the (k, s)-RdB sequence. In order to do so, ck,s’s length, denoted byℓ(ck,s), is needed calculating first. It’s then essential to show that ℓ(ck,s)is equal toU(k, s)by some algebraic transformations.
Given a word u, denote ⟨u⟩to be its minimal rotation. For instance, the minimal rotation of 010110 is 001011, or, the minimal rotation of 010101 is itself. For every word v, we define:
S(v) =n exceed v. The following example 4.4 lists all element of S(v)withv= 01101 .whose minimal rotations are at most vis:
S(01101) = 00000 , 00001 ,00010 ,00100 ,01000 ,10000 , 00011 ,00110 ,01100 ,11000 ,10001 , 00111 ,01110 ,11100 ,11001 ,10011 equals to the length of the prefix of the granddaddy sequence x, from the beginning to the sub-string v. Recall that uk,sis also a Lyndon word, one has:
S(uk,s)= 2k−(ℓ(ck,s)−(k−1)−s) ⇔ℓ(ck,s) = 2k+ (k−1) +s−S(uk,s) (4.9) This brings the idea determining ℓ(ck,s)by computing the size of the set S(uk,s).
Lemma 7. LetAt= 2t−2for all t >1,A1= 1, and M= max ( k−s, s+ 3). Then:
S(uk,s)= 1 +kX t=1At (4.10) Proof. Leti, jbe two non-negative integers such that i+j < k , denote:
Ui,j= 0i1x1t0j∈S(uk,s) :i+j+t=k to be the set of all words in S(uk,s)satisfying its prefix of length i+ 1is0i1and its suffix of length j+ 1is10j.
Since S(uk,s)is the disjoint union of 0kand all sets Ui,jfori, j⩾0andi+j < k , we obtain:
S(uk,s)= 1 +X If we fix 1⩽t⩽k, there are k−t+ 1pairs (i, j)such that t=k−i−j. If i+j⩽sthen the sub-string 1x1tmust contain s+ 1consecutive 0’s (consequently,C1=X i,j⩾0; where M= max( s+ 3, k−s).
Ifk > i +j > s then the sub-string (xi+2, . . . , x k−j−1)can be any word of length C2=X i,j⩾0; t=1(k−t+ 1)At. (4.13) From Equations (4.11), (4.12), (4.13), we get the result in Lemma 7.
Combining the results from Lemma 7 and equation 4.9 gives:
ℓ(ck,s) = 2k+k+s−2− C1− C2 where C1andC2are defined in Equation 4.12 and 4.13. It’s now ready to prove the following lemma, which states that the proposed construction is optimal.
Lemma 8. The length the sequence ck,sreturned from Construction 1 is optimal, that is:
ℓ(ck,s) =U(k, s) (4.14) Proof. Equation 4.14 is equivalent to:
+ (k−1) (4.15) First, the value of CandMis necessarily explicated by considering the relation between kands. In short, there are 3following cases:
  M=k−s, C =s−1ifs+ 3⩽k−s M=s+ 3, C=s−1ifk= 2s+ 2, s < k −1 M=s+ 2, C=k−s−2ifk⩽2s+ 1Case 1 :M=k−s, C =s−1when s+ 3⩽k−s. The equation needing to be proved 4.15 becomes:
= 2k− 1 +kX t=1(k−t+ 1)At  RHS = 2k− 1 +kX t=1(k−t+ 1)At  = 2k− 1 +kX t=1(k−t+ 1)At−kX = 2k− 2k−kX (the term 1 +kX t=1(k−t+ 1)Atcan be easily shown to be equal to 2k) =kX Thus:
LHS = RHS =kX Recall that:Therefore, when k⩾2s+ 3, the following system of equations is obtained:
  ··· Adding side by side the above equations results in the equation (∗), which is needed to be verified.
Case 2 :M=s+ 3, C=s−1when k= 2s+ 2, s < k −1. The LHS is the same as in the first case, meanwhile, the RHS is :
RHS =2k− 1 +2s+2X t=1(k−t+ 1)At  =2k− 1 +2s+2X t=1At−2s+2X =2s+2X =kX what’s left to be proved is similar to the first case.
Case 3 :M=s+ 3, C=k−s−2when s+ 2⩽k⩽2s+ 1. Again, the RHS is RHS =Pk Therefore:
LHS = RHS  ··· with k−t=s+ 1 ··· Once again, adding side by side the above equations gives (∗∗).
In conclusion, in all 3cases, the correctness of equation 4.15 is verified, hence, Lemma 8 is proved.Summary In this thesis, Run length limited de Bruijn sequences are introduced and studied to replace Hybrid de Bruijn sequence in dBTS system. Compare to HdB sequences, RdB sequences not only have a higher rate but are also more general and adaptive.
The main results of this thesis include the explicit formula of the maximal length and maximal asymptotic rate of RdB sequences. To achieve such length and rate,an encoding algorithm is presented. This thesis also provides proof of the opti mality of the encoder. To locate the position of a proper substring in the whole encoded sequence, a decoding algorithm is proposed based on the decoder of thegranddaddy sequence. The encoder and decoder are both based on state-of-the art algorithms. The encoder’s complexity is constant amortized time per symbol, and the decoder’s complexity is sub-ar with respect to the length of the RdB sequence.
Future works In future work, it’s critical to analyze deeper about the RdB sequence undersome other constraints like weight constraint or local constraint. The current re sults right now just focus on the alphabet of size 2. The study of the more generalalphabet will raise many more questions in combinatorics and algorithm. Espe cially, results for the alphabet of size 4will be valuable in the research of DNA storage as well as DNA sequencing, a very interesting field recently.
Publications 1. Yeow Meng Chee, Duc Tu Dao, Tien Long Nguyen , Duy Hoang Ta, VanKhu Vu. ”Run Length Limited de Bruijn Sequences for Quantum Communi cations”, The 2022 IEEE International Symposium on Information Theory.
2. Tran Ba Trung, Lijun Chang, Nguyen Tien Long , Kai Yao, Huynh Thi Thanh Binh. ”Verification-Free Approaches to Efficient Locally Densest SubgraphDiscovery”, The 39th IEEE International Conference on Data Engineering. P. Zhang, D. K. Oi, D. Lowndes, and J. G. Rarity, “Timing and synchronisa tion for high-loss free-space quantum communication with hybrid de bruijn codes,” IET Quantum Communication , vol. 2, no. 3, pp. 80–89, 2021.
P. W. Shor, “Polynomial-time algorithms for prime factorization and discrete logarithms on a quantum computer,” SIAM review , vol. 41, no. 2, pp. 303– 332, 1999.
V . Gheorghiu and M. Mosca, “Benchmarking the quantum cryptanalysis of symmetric, public-key and hash-based cryptographic schemes,” arXiv preprint arXiv:1902.02332 , 2019.
C. H. Bennett and G. Brassard, “Quantum cryptography: Public key distri bution and coin tossing,” in Proceedings of IEEE International Conference on Computers, Systems and Signal Processing , IEEE, vol. 175, 1984, p. 8.
A. K. Ekert, “Quantum cryptography and bell’s theorem,” in Quantum Mea surements in Optics , Springer, 1992, pp. 413–418.
I. Khader, H. Bergeron, L. C. Sinclair, W. C. Swann, N. R. Newbury, andJ.-D. Desch ˆenes, “Time synchronization over a free-space optical communi cation channel,” Optica , vol. 5, no. 12, pp. 1542–1548, 2018.
S. Duan, S. Cong, and Y . Song, “A survey on quantum positioning system,” International Journal of Modelling and Simulation , vol. 41, no. 4, pp. 265– 283, 2021.
S. Ling and C. Xing, Coding theory: a first course . Cambridge University Press, 2004.
K. S. Immink, “Runlength-limited sequences,” Proceedings of the IEEE , vol. 78, no. 11, pp. 1745–1759, 1990.
L. Song, F. Geng, Z. Song, B.-Z. Li, and Y .-J. Yuan, “Robust data storage in dna by de bruijn graph-based decoding,” 2021.
T. Etzion and A. Lempel, “Algorithms for the generation of full-length shift register sequences,” IEEE Transactions on Information Theory , vol. 30, no. 3, pp. 480–484, 1984.
H. Fredricksen, “A survey of full length nonar shift register cycle algo rithms,” SIAM review , vol. 24, no. 2, pp. 195–221, 1982. A. Lempel, “On a homomorphism of the de bruijn graph and its applications to the design of feedback shift registers,” IEEE Transactions on Computers , vol. 100, no. 12, pp. 1204–1209, 1970.
M. Cohn and A. Lempel, “On fast m-sequence transforms (corresp.),” IEEE Transactions on Information Theory , vol. 23, no. 1, pp. 135–137, 1977.
T. van Aardenne-Ehrenfest, “Circuits and trees in oriented ar graphs,” Simon Stevin , vol. 28, pp. 203–217, 1951.
M. Fleury, “Deux problemes de geometrie de situation,” Journal de mathe matiques elementaires , vol. 2, no. 2, pp. 257–261, 1883.
C. Hierholzer and C. Wiener, “ ¨Uber die m ¨oglichkeit, einen linienzug ohnewiederholung und ohne unterbrechung zu umfahren,” Mathematische An nalen , vol. 6, no. 1, pp. 30–32, 1873.
M. H. Martin, “A problem in arrangements,” Bulletin of the American Math ematical Society , vol. 40, no. 12, pp. 859–864, 1934.
A. M. Alhakim, “A simple combinatorial algorithm for de bruijn sequences,” The American Mathematical Monthly , vol. 117, no. 8, pp. 728–732, 2010.
A. Alhakim, E. Sala, and J. Sawada, “Revisiting the prefer-same and prefer opposite de bruijn sequence constructions,” Theoretical Computer Science , vol. 852, pp. 73–77, 2021.
C. J. Mitchell, T. Etzion, and K. G. Paterson, “A method for constructing decodable de bruijn sequences,” IEEE Transactions on Information Theory , vol. 42, no. 5, pp. 1472–1478, 1996.
J. Tuliani, “De bruijn sequences with efficient decoding algorithms,” Dis crete Mathematics , vol. 226, no. 1-3, pp. 313–336, 2001.
T. Kociumaka, J. Radoszewski, and W. Rytter, “Efficient ranking of lyndon words and decoding lexicographically minimal de bruijn sequence,” SIAM Journal on Discrete Mathematics , vol. 30, no. 4, pp. 2027–2046, 2016.
D. E. Knuth, Art of Computer Programming, Volume 4, Fascicle 4, The: Generating All Trees–History of Combinatorial Generation . Addison-Wesley Pro fessional, 2013.
H. Fredricksen and J. Maiorana, “Necklaces of beads in k colors and k-ary de bruijn sequences,” Discrete Mathematics , vol. 23, no. 3, pp. 207–210, 1978.
H. Fredricksen and I. J. Kessler, “An algorithm for generating necklaces of beads in two colors,” Discrete mathematics , vol. 61, no. 2-3, pp. 181–188, 1986. F. Ruskey, C. Savage, and T. M. Y . Wang, “Generating necklaces,” Journal of Algorithms , vol. 13, no. 3, pp. 414–430, 1992.
F. Chung, P. Diaconis, and R. Graham, “Universal cycles for combinatorial structures,” Discrete Mathematics , vol. 110, no. 1-3, pp. 43–59, 1992.
V . Horan and G. Hurlbert, “Universal cycles for weak orders,” SIAM Journal on Discrete Mathematics , vol. 27, no. 3, pp. 1360–1371, 2013.
B. Jackson, B. Stevens, and G. Hurlbert, “Research problems on gray codes and universal cycles,” Discrete Mathematics , vol. 309, no. 17, pp. 5341– 5348, 2009.
J. R. Johnson, “Universal cycles for permutations,” Discrete Mathematics , vol. 309, no. 17, pp. 5264–5270, 2009.
G. Hurlbert, T. Johnson, and J. Zahl, “On universal cycles for multisets,” Discrete mathematics , vol. 309, no. 17, pp. 5321–5327, 2009.
B. W. Jackson, J. Buhler, and R. Mayer, “A recursive construction for univer sal cycles of 2-subspaces,” Discrete mathematics , vol. 309, no. 17, pp. 5328– 5331, 2009.
G. Hurlbert, “On universal cycles for k-subsets of an n-set,” SIAM Journal on Discrete Mathematics , vol. 7, no. 4, pp. 598–604, 1994.
B. W. Jackson, “Universal cycles of k-subsets and k-permutations,” Discrete mathematics , vol. 117, no. 1-3, pp. 141–150, 1993.
E. Moreno, “On the theorem of fredricksen and maiorana about de bruijn sequences,” Advances in Applied Mathematics , vol. 33, no. 2, pp. 413–415, 2004.
Y . H. Au, “Generalized de bruijn words for primitive words and powers,” Discrete Mathematics , vol. 338, no. 12, pp. 2320–2331, 2015.
J. Sawada, A. Williams, and D. Wong, “Generalizing the classic greedy andnecklace constructions of de bruijn sequences and universal cycles,” the elec tronic journal of combinatorics , P1–24, 2016.
S. Golomb, S.-R. Sequences, and S. F. Holden-Day, “Ca, 1967,” Aegean Park, 1982.
A. Lempel, “Cryptology in transition,” ACM Computing Surveys (CSUR) , vol. 11, no. 4, pp. 285–303, 1979.
A. H. Chan, R. A. Games, and E. L. Key, “On the complexities of de bruijn sequences,” Journal of Combinatorial Theory, Series A , vol. 33, no. 3, pp. 233– 246, 1982. R. Games and A. Chan, “A fast algorithm for determining the complexity ofa binary sequence with period 2ˆ n (corresp.),” IEEE Transactions on Infor mation Theory , vol. 29, no. 1, pp. 144–146, 1983.
E. Key, “An analysis of the structure and complexity of nonar binary sequence generators,” IEEE Transactions on Information Theory , vol. 22, no. 6, pp. 732–736, 1976.
T. Etzion, N. Kalouptsidis, N. Kolokotronis, K. Limniotis, and K. G. Pater son, “Properties of the error ar complexity spectrum,” IEEE Transactions on Information Theory , vol. 55, no. 10, pp. 4681–4686, 2009.
T. Etzion and A. Lempel, “Construction of de bruijn sequences of mini mal complexity,” IEEE Transactions on Information Theory , vol. 30, no. 5, pp. 705–709, 1984.
A. Lempel and M. Cohn, “Design of universal test sequences for vlsi,” IEEE transactions on information theory , vol. 31, no. 1, pp. 10–17, 1985.
Z. Barzilai, D. Coppersmith, and A. L. Rosenberg, “Exhaustive generation of bit patterns with applications to vlsi self-testing,” IEEE Transactions on Computers , vol. 32, no. 02, pp. 190–194, 1983.
F. J. MacWilliams and N. J. Sloane, “Pseudo-random sequences and arrays,” Proceedings of the IEEE , vol. 64, no. 12, pp. 1715–1729, 1976.
T. Etzion, “Constructions for perfect maps and pseudorandom arrays,” IEEE Transactions on information theory , vol. 34, no. 5, pp. 1308–1316, 1988.
A. M. Bruckstein, T. Etzion, R. Giryes, N. Gordon, R. J. Holt, and D. Shuldiner,“Simple and robust binary self-location patterns,” IEEE transactions on in formation theory , vol. 58, no. 7, pp. 4884–4889, 2012.
Y .-C. Hsieh, “Decoding structured light patterns for three-dimensional imag ing systems,” Pattern Recognition , vol. 34, no. 2, pp. 343–349, 2001.
R. A. Morano, C. Ozturk, R. Conn, S. Dubin, S. Zietz, and J. Nissano, “Structured light using pseudorandom codes,” IEEE Transactions on Pattern Anal ysis and Machine Intelligence , vol. 20, no. 3, pp. 322–327, 1998.
J. Pages, J. Salvi, C. Collewet, and J. Forest, “Optimised de bruijn patterns for one-shot shape acquisition,” Image and Vision Computing , vol. 23, no. 8, pp. 707–720, 2005.
J. Salvi, S. Fernandez, T. Pribanic, and X. Llado, “A state of the art in struc tured light patterns for surface profilometry,” Pattern recognition , vol. 43, no. 8, pp. 2666–2680, 2010. R. G. Van Schyndel, A. Z. Tirkel, and C. F. Osborne, “A digital watermark,” inProceedings of 1st international conference on image processing , IEEE, vol. 2, 1994, pp. 86–90.
M. J. Chaisson, D. Brinza, and P. A. Pevzner, “De novo fragment assem bly with short mate-paired reads: Does the read length matter?” Genome research , vol. 19, no. 2, pp. 336–346, 2009.
P. E. Compeau, P. A. Pevzner, and G. Tesler, “How to apply de bruijn graphs to genome assembly,” Nature biotechnology , vol. 29, no. 11, pp. 987–991, 2011.
P. A. Pevzner, H. Tang, and M. S. Waterman, “A new approach to fragment assembly in dna sequencing,” in Proceedings of the fifth annual international conference on Computational biology , 2001, pp. 256–267.
Y . Zhang and M. S. Waterman, “An eulerian path approach to global multiple alignment for dna sequences,” Journal of Computational Biology , vol. 10, no. 6, pp. 803–819, 2003.
Z. Chang, J. Chrisnata, M. F. Ezerman, and H. M. Kiah, “Rates of dna se quence profiles for practical values of read lengths,” IEEE Transactions on Information Theory , vol. 63, no. 11, pp. 7166–7177, 2017.
H. M. Kiah, G. J. Puleo, and O. Milenkovic, “Codes for dna sequence pro files,” IEEE Transactions on Information Theory , vol. 62, no. 6, pp. 3125– 3146, 2016.
Y . M. Chee, T. Etzion, H. M. Kiah, S. Marcovich, A. Vardy, E. Yaakobi, et al. , “Locally-constrained de bruijn codes: Properties, enumeration, code constructions, and applications,” IEEE Transactions on Information Theory , vol. 67, no. 12, pp. 7857–7875, 2021.
I. F. Blake, “The enumeration of certain run-length sequences,” Inf. Control. , vol. 55, no. 1-3, pp. 222–236, 1982.
O. F. Kurmaev, “Constant-weight and constant-charge binary run-length lim ited codes,” IEEE transactions on information theory , vol. 57, no. 7, pp. 4497– 4515, 2011.
J.-P. Duval, “G ´en´eration d’une section des classes de conjugaison et ar bre des mots de lyndon de longueur born ´ee,”Theoretical computer science , vol. 60, no. 3, pp. 255–283, 1988.